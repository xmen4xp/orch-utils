// SPDX-FileCopyrightText: (C) 2025 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	"sync"
	"fmt"
	"time"
	"os"
	"strconv"
	"strings"
	customerrors "errors"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/rest"
	cache "k8s.io/client-go/tools/cache"
	"github.com/sirupsen/logrus"
	"reflect"
	"k8s.io/client-go/dynamic"
	fakeDynamicClientset "k8s.io/client-go/dynamic/fake"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/runtime"

{{.HelperImport}}
{{.CommonImport}}
baseClientset {{.BaseClientsetImport}}
fakeBaseClienset {{.FakeBaseCliensetImport}}

{{.BaseImports}}
{{.InformerImports}}
)

var logger = logrus.New()
const maxRetryCount = 60
const sleepTime = 5
const maxRetryCount1SecSleep = 300

const ownershipAnnotation string = "Ownership"
const nexusDeferredDeleteAnnotation string = "nexus.com/nexus-deferred-delete"

// informerResyncPeriod is in second, default value is 10 Hrs(36000 Sec). INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
var informerResyncPeriod time.Duration = 36000

type Clientset struct {
	baseClient baseClientset.Interface
	DynamicClient               dynamic.Interface
	{{ range $key, $group := .ApiGroups }}{{$group.ClientsetApiGroups}}{{ end }}
}

type subscription struct {
	informer     cache.SharedIndexInformer
	stop chan    struct{}
	WriteCacheObjects *sync.Map
}

// subscriptionMap will store crd string as key and value as subscription type,
// for example key="roots.orgchart.vmware.org" and value=subscription{}
var subscriptionMap = sync.Map{}

func subscribe(key string, informer cache.SharedIndexInformer){
	s:=subscription{
		informer: informer,
		stop: make(chan struct{}),
		WriteCacheObjects: &sync.Map{},
	}
	go s.informer.Run(s.stop)
	subscriptionMap.Store(key,s)
}

func (c *Clientset) SubscribeAll() {	
	var key string
	{{ range $key, $node := .Nodes }}
	key = "{{$node.CrdName}}"
	if _,ok := subscriptionMap.Load(key); !ok {
		informer := {{$node.GroupInformerImport}}.New{{$node.BaseNodeName}}Informer(c.baseClient, informerResyncPeriod * time.Second, cache.Indexers{})
		subscribe(key, informer)

		{{if $node.Parent.HasParent}}
		chainer := {{$node.GroupResourceType}}Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)
		{{end}}
	}
	{{end}}
}

func (c *Clientset) UnsubscribeAll() {
    subscriptionMap.Range(func(key, s interface{})bool{
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
		return true
	})
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}

	customFormatter := new(logrus.TextFormatter)
	customFormatter.TimestampFormat = "2006-01-02 15:04:05"
	logger.SetFormatter(customFormatter)
	customFormatter.FullTimestamp = true
	if os.Getenv("NEXUS_LOG_LEVEL") == "debug" {
		logger.SetLevel(logrus.DebugLevel)
		logger.Debug("Nexus debug log enabled")
	}

	// INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
	stringResyncPeriod := os.Getenv("INFORMER_RESYNC_PERIOD")
	if 	stringResyncPeriod != "" {
		intResyncPeriod, err := strconv.Atoi(stringResyncPeriod)
		if err != nil {
			logger.Errorf("env INFORMER_RESYNC_PERIOD is not set with correct value")
		} else {
			informerResyncPeriod = time.Duration(intResyncPeriod)
			logger.Debugf("Resync Period for informers is set to %+v second", informerResyncPeriod)
		}
	}

	client := &Clientset{}
	client.baseClient = baseClient
	client.DynamicClient, _ = dynamic.NewForConfig(config) // TBD: check and react for error
	{{ range $key, $group := .ApiGroups }}{{$group.InitApiGroups}}{{ end }}

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	scheme := runtime.NewScheme()
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	client.DynamicClient = fakeDynamicClientset.NewSimpleDynamicClient(scheme)
	{{ range $key, $group := .ApiGroups }}{{$group.InitApiGroups}}{{ end }}
	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

{{ range $key, $group := .ApiGroups }}{{$group.ClientsetsApiGroupMethods}}{{ end }}

{{ range $key, $group := .ApiGroups }}
type
{{$group.GroupTypeName}} struct {
client *Clientset
}

func new{{$group.GroupTypeName}}(client *Clientset) *{{$group.GroupTypeName}} {
	return &{{$group.GroupTypeName}}{
		client: client,
	}
}
{{end}}


{{ range $key, $node := .Nodes }}

func (group *{{$node.GroupTypeName}}) Get{{$node.BaseNodeName}}ChildrenMap() (map[string]{{$node.BaseImportName}}.Child) {
	return map[string]{{$node.BaseImportName}}.Child{}
}

func (group *{{$node.GroupTypeName}}) Get{{$node.BaseNodeName}}Child(grp, kind, name string) ({{$node.BaseImportName}}.Child) {
	return {{$node.BaseImportName}}.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// Get{{$node.BaseNodeName}}ByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *{{$node.GroupTypeName}}) Get{{$node.BaseNodeName}}ByName(ctx context.Context, hashedName string) (*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, error) {
	key := "{{$node.CrdName}}"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			logger.Debugf("[Get{{$node.BaseNodeName}}ByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*{{$node.GroupBaseImport}})
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				logger.Fatalf("[Get{{$node.BaseNodeName}}ByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*{{$node.GroupBaseImport}}).ResourceVersion)
				if writeCacheVersionErr != nil {
					logger.Fatalf("[Get{{$node.BaseNodeName}}ByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					 s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
					client: group.client,
					{{$node.BaseNodeName}}: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
					client: group.client,
					{{$node.BaseNodeName}}: resWrCache.(*{{$node.GroupBaseImport}}),
				}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
		{{$node.GroupTypeName}}().
		{{$node.GroupResourceNameTitle}}().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
				client: group.client,
				{{$node.BaseNodeName}}: result,
			}, nil
		} else if errors.IsNotFound(err) {
			logger.Debugf("[Get{{$node.BaseNodeName}}ByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded){
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v",retryCount,hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on Get {{$node.GroupResourceNameTitle}}: %s",hashedName)
					return nil, err
				}
				retryCount +=1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled){
				logger.Errorf("[Get{{$node.BaseNodeName}}ByName]: %+v",err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[Get{{$node.BaseNodeName}}ByName]: %+v",err)
				return nil, err
			}
		}
	}
}

// ForceRead{{$node.BaseNodeName}}ByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *{{$node.GroupTypeName}}) ForceRead{{$node.BaseNodeName}}ByName(ctx context.Context, hashedName string) (*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, error) {
	logger.Debugf("[ForceRead{{$node.BaseNodeName}}ByName] Received object :%s to read from DB",hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
		{{$node.GroupTypeName}}().
		{{$node.GroupResourceNameTitle}}().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[ForceRead{{$node.BaseNodeName}}ByName] Failed to Get {{$node.GroupResourceNameTitle}}: %+v",err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded){
				logger.Errorf("[Retry Count: %d ] %+v",retryCount,err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max Retry exceed on Get {{$node.GroupResourceNameTitle}}: %s",hashedName)
					return nil, err
				}
				retryCount +=1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled){
				logger.Errorf("[ForceRead{{$node.BaseNodeName}}ByName]: %+v",err)
				return nil, context.Canceled
			} else {
				logger.Errorf("[ForceRead{{$node.BaseNodeName}}ByName]: %+v",err)
				return nil, err
			}
		} else {
			logger.Debugf("[ForceRead{{$node.BaseNodeName}}ByName] Executed Successfully :%s",hashedName)
			return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
				client: group.client,
				{{$node.BaseNodeName}}: result,
			}, nil
		}
	}
}

// Delete{{$node.BaseNodeName}}ByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *{{$node.GroupTypeName}}) Delete{{$node.BaseNodeName}}ByName(ctx context.Context, hashedName string) (err error) {
	logger.Debugf("[Delete{{$node.BaseNodeName}}ByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result *{{$node.GroupBaseImport}}
	)
	{{if or .HasChildren .Parent.HasParent }}
	retryCount = 0
	for {
		result, err = group.client.baseClient.
		{{$node.GroupTypeName}}().
		{{$node.GroupResourceNameTitle}}().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			logger.Errorf("[Delete{{$node.BaseNodeName}}ByName] Failed to get {{$node.GroupResourceNameTitle}}: %+v",err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded){
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v",retryCount,hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on get {{$node.GroupResourceNameTitle}}: %s",hashedName)
					return err
				}
				retryCount +=1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled){
				logger.Errorf("[Delete{{$node.BaseNodeName}}ByName] context canceled: %s",hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err){
				logger.Errorf("[Delete{{$node.BaseNodeName}}ByName] Object: %s not found",hashedName)
				break
			} else {
				logger.Errorf("[Delete{{$node.BaseNodeName}}ByName] Object: %s unexpected error: %+v",hashedName,err)
				return err
			}
		} else {
			break
		}
	}
	{{ end }}

	if result == nil {
		return err
	}
	{{ range $key, $link := .Children }}
	for _, child := range GetChildren("{{$node.CrdName}}", hashedName, "{{$link.CrdName}}") {
		err := group.client.{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("{{$node.CrdName}}", hashedName, "{{$link.CrdName}}", child)
	}
	{{ end }}

	retryCount = 0
	for {
		err = group.client.baseClient.
		{{$node.GroupTypeName}}().
		{{$node.GroupResourceNameTitle}}().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			logger.Errorf("[Delete{{$node.BaseNodeName}}ByName] failed to delete {{$node.GroupResourceNameTitle}}: %+v",err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v",retryCount,hashedName, err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on delete {{$node.GroupResourceNameTitle}}: %s",hashedName)
					return err
				}
				retryCount +=1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled){
				logger.Errorf("[Delete{{$node.BaseNodeName}}ByName]: context canceled: %s",hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err){
				logger.Errorf("[Delete{{$node.BaseNodeName}}ByName] Object: %s not found",hashedName)
				break
			} else {
				logger.Errorf("[Delete{{$node.BaseNodeName}}ByName] Object: %s unexpected error: %+v",hashedName,err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("{{$node.CrdName}}"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch
	{{if .Parent.HasParent}}
	logger.Debugf("[Delete{{$node.BaseNodeName}}ByName] Get parent details for object: %s",hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["{{$node.Parent.CrdName}}"]
	if !ok {
		parentName = helper.DefaultKey
	}
	if result.GetLabels() != nil {
		if parents[common.IsNameHashedLabel] == "true" {
			parentName = helper.GetHashedName("{{$node.Parent.CrdName}}", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("{{$node.Parent.CrdName}}", parents, parentName)
	}
	RemoveChild("{{$node.Parent.CrdName}}", parentName, "{{$node.CrdName}}", hashedName)
	{{ end }}
	return nil
}

// Create{{$node.BaseNodeName}}ByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *{{$node.GroupTypeName}}) Create{{$node.BaseNodeName}}ByName(ctx context.Context,
	objToCreate *{{$node.GroupBaseImport}}) (*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, error) {
	logger.Debugf("[Create{{$node.BaseNodeName}}ByName] Received objToCreate: %s",objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DisplayNameLabel]; !ok {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
	}
	{{if $node.IsSingleton }}if objToCreate.Labels[common.DisplayNameLabel] == "" {
		objToCreate.Labels[common.DisplayNameLabel] = helper.DefaultKey
	}
	if objToCreate.Labels[common.DisplayNameLabel] != helper.DefaultKey {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DisplayNameLabel])
	}{{end}}

	{{if $node.DeferredDelete}}
	logger.Debugf("[Create{{$node.BaseNodeName}}ByName] Node is marked for deferred delete: %s", objToCreate.GetName())
	found := false
	for _, finalizer := range objToCreate.Finalizers {
		if finalizer == nexusDeferredDeleteAnnotation {
			found = true
			break
		}
	}
	if !found {
		objToCreate.Finalizers = append(objToCreate.Finalizers, nexusDeferredDeleteAnnotation)
		logger.Debugf("[Create{{$node.BaseNodeName}}ByName] Added %s finalizer to node: %s", nexusDeferredDeleteAnnotation, objToCreate.GetName())
	}
	{{end}}

	{{ range $key, $link := .LinksAndChildren }}objToCreate.Spec.{{$link.FieldName}}Gvk = nil
	{{ end }}
	var (
		retryCount int
		result *{{$node.GroupBaseImport}}
		err error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
		{{$node.GroupTypeName}}().
		{{$node.GroupResourceNameTitle}}().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			logger.Errorf("[Create{{$node.BaseNodeName}}ByName] Failed to create {{$node.BaseNodeName}}: %s, error: %+v",objToCreate.GetName(),err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded){
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v",retryCount,objToCreate.GetName(),err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on create {{$node.BaseNodeName}}: %s",objToCreate.GetName())
					return nil,err
				}
				retryCount +=1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled){
				logger.Errorf("[Create{{$node.BaseNodeName}}ByName] context canceled while creating {{$node.BaseNodeName}}: %s",objToCreate.GetName())
				return nil,context.Canceled
			}{{if .Parent.HasParent}} else if errors.IsAlreadyExists(err) {
				logger.Debugf("[Create{{$node.BaseNodeName}}ByName] {{$node.BaseNodeName}}: %s already exists, error: %+v",objToCreate.GetName(), err)
				result, err = group.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					logger.Fatalf("[Create{{$node.BaseNodeName}}ByName] Unable to Get {{$node.BaseNodeName}} %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			}{{ end }} else {
				logger.Errorf("[Create{{$node.BaseNodeName}}ByName] found unexpected error while creating {{$node.BaseNodeName}}: %s, error: %+v",objToCreate.GetName(),err)
				return nil,err
			}
		} else {
			logger.Debugf("[Create{{$node.BaseNodeName}}ByName] {{$node.BaseNodeName}}: %s created successfully",objToCreate.GetName())
			if s, ok := subscriptionMap.Load("{{$node.CrdName}}"); ok {
				logger.Debugf("[Create{{$node.BaseNodeName}}ByName] {{$node.BaseNodeName}}: %s stored in wr-cache",objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}
	{{if .Parent.HasParent}}
	parentName, ok := objToCreate.GetLabels()["{{$node.Parent.CrdName}}"]
	if !ok {
		parentName = helper.DefaultKey
	}
	parentHashedName := helper.GetHashedName("{{$node.Parent.CrdName}}", objToCreate.GetLabels(), parentName)

	AddChild("{{$node.Parent.CrdName}}", parentHashedName, "{{$node.CrdName}}", objToCreate.Name)
	{{ end }}

	logger.Debugf("[Create{{$node.BaseNodeName}}ByName] Executed Successfully: %s",objToCreate.GetName())
	return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
		client: group.client,
		{{$node.BaseNodeName}}: result,
	}, nil
}

{{if .HasStatus}}
// Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName sets user defined status
func (group *{{$node.GroupTypeName}}) Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName(ctx context.Context,
	objToUpdate *{{$node.GroupBaseImport}}, status *{{$node.BaseImportName}}.{{$node.StatusType}}) (*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, error) {
	logger.Debugf("[Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName] Received objToUpdate:%s",objToUpdate.GetName())

	gvr := schema.GroupVersionResource{
		Group:    "{{$node.Group}}",
		Version:  "v1",
		Resource:  strings.ToLower("{{$node.GroupResourceNameTitle}}"),
	}

	hashedName := objToUpdate.ObjectMeta.Name
	obj := {{$node.GroupBaseImport}}{}
	obj.Kind =  strings.ToLower("{{$node.GroupResourceNameTitle}}")
	obj.APIVersion = "{{$node.Group}}/v1"
	obj.ObjectMeta = objToUpdate.ObjectMeta
	obj.Status.{{$node.StatusName}} = *status

	var mapInterface map[string]interface{}
	marshalledObj, _ := json.Marshal(&obj)
	json.Unmarshal(marshalledObj, &mapInterface)

	newCtx := context.TODO()
	retryCount := 0
	for {
		_, err := group.client.DynamicClient.Resource(gvr).UpdateStatus(ctx, &unstructured.Unstructured{Object: mapInterface}, metav1.UpdateOptions{})
		if err == nil {
			logger.Debugf("[Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName] Updating status for {{$node.BaseNodeName}} node %s successful", hashedName)
			break
		}

		logger.Errorf("[Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName] Updating status for {{$node.BaseNodeName}} node: %s failed with error %v. Retrying...", hashedName, err)

		updatedObj, err:= group.ForceRead{{$node.BaseNodeName}}ByName(newCtx, hashedName)
		if err == nil {
			obj.ObjectMeta = updatedObj.ObjectMeta
			marshalledObj, _ := json.Marshal(&obj)
			json.Unmarshal(marshalledObj, &mapInterface)
		}

		retryCount += 1
		if retryCount == maxRetryCount1SecSleep {
			logger.Fatalf("[Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName] Max retry exceeded for updating status for {{$node.BaseNodeName}} node: %s", hashedName)
			return nil, err
		}
		time.Sleep(time.Second)
	}

/*
	if s, ok := subscriptionMap.Load("{{$node.CrdName}}"); ok {
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		var objectToWrite *{{$node.GroupBaseImport}}
		if inWrCache {
			objectToWrite = resWrCache.(*{{$node.GroupBaseImport}})
			objectToWrite.Status.{{$node.StatusName}} = *status
		} else {
			// Object is not in write cache. Populate the write cache with last "known" object.
			// TBD: Is this right ???
			//      Can we expect ObjectToUpdate to the latest version of the object ?
			//      What if we received the object spec but only want to update the status ?
			//      Get on the object will return a object form cache if the cache has newer version.
			// 		So proceeding with assumption that if newer version is available, user will get the newer version anyways.
			objectToWrite = objToUpdate
			objToUpdate.Status.{{$node.StatusName}} = *status
		}
		s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), objectToWrite)
	}
*/
	return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
		client: group.client,
		{{$node.BaseNodeName}}: objToUpdate, // TBD: To be fixed to return back the "result"
	}, nil
}
{{ end }}

// Update{{$node.BaseNodeName}}ByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *{{$node.GroupTypeName}}) Update{{$node.BaseNodeName}}ByName(ctx context.Context,
	objToUpdate *{{$node.GroupBaseImport}}) (*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, error) {
	logger.Debugf("[Update{{$node.BaseNodeName}}ByName] Received objToUpdate: %s",objToUpdate.GetName())
	{{if $node.IsSingleton }}if objToUpdate.Labels[common.DisplayNameLabel] != helper.DefaultKey {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DisplayNameLabel])
	}{{end}}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current , err := group.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations !=nil {
			if current.Annotations[ownershipAnnotation] != ""{
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if  objToUpdate.Labels !=nil {
			parentsList := helper.GetCRDParentsMap()["{{$node.CrdName}}"]
			for _,k := range parentsList{
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IsNameHashedLabel] = current.Labels[common.IsNameHashedLabel]
			objToUpdate.Labels[common.DisplayNameLabel] = current.Labels[common.DisplayNameLabel]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	    patch = append(patch, PatchOp{
			Op:    "replace",
			Path:  "/metadata/finalizers",
			Value: objToUpdate.Finalizers,
		})
	}

	{{ if gt (len .Fields) 0}}
	var rt reflect.Type
	{{ end }}
	{{ range $key, $field := .Fields }}
	rt = reflect.TypeOf(objToUpdate.Spec.{{$field.FieldName}})
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.{{$field.FieldName}}).IsNil(){
			patchValue{{$field.FieldName}} := objToUpdate.Spec.{{$field.FieldName}}
			patchOp{{$field.FieldName}} := PatchOp{
				Op:    "replace",
				Path:  "/spec/{{$field.FieldNameTag}}",
				Value: patchValue{{$field.FieldName}},
			}
			patch = append(patch, patchOp{{$field.FieldName}})
		}
	} else {
		patchValue{{$field.FieldName}} := objToUpdate.Spec.{{$field.FieldName}}
		patchOp{{$field.FieldName}} := PatchOp{
			Op:    "replace",
			Path:  "/spec/{{$field.FieldNameTag}}",
			Value: patchValue{{$field.FieldName}},
		}
		patch = append(patch, patchOp{{$field.FieldName}})
	}
	{{ end }}
	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *{{$node.GroupBaseImport}}
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
		{{$node.GroupTypeName}}().
		{{$node.GroupResourceNameTitle}}().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			logger.Errorf("[Update{{$node.BaseNodeName}}ByName] Failed to patch {{$node.BaseNodeName}} %s with error: %+v",objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded){
				logger.Debugf("[Retry count: (%d) obj: %s ] %+v",retryCount,objToUpdate.GetName(),err)
				if retryCount == maxRetryCount {
					logger.Errorf("Max retry exceed on patching: %s",objToUpdate.GetName())
					logger.Debugf("Trigger {{$node.BaseNodeName}} Delete: %s",objToUpdate.GetName())
					delErr := group.Delete{{$node.BaseNodeName}}ByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						logger.Debugf("Error occur while deleting {{$node.BaseNodeName}}: %s",objToUpdate.GetName())
						return nil, delErr
					}
					logger.Debugf("{{$node.BaseNodeName}} deleted: %s",objToUpdate.GetName())
					return nil, err
				}
				retryCount +=1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled){
				logger.Errorf("[Update{{$node.BaseNodeName}}ByName]: context canceled: %s",objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				logger.Errorf("[Update{{$node.BaseNodeName}}ByName] Object: %s unexpected error: %+v",objToUpdate.GetName(),err)
				logger.Debugf("Trigger {{$node.BaseNodeName}} Delete: %s",objToUpdate.GetName())
				delErr := group.Delete{{$node.BaseNodeName}}ByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					logger.Debugf("Error occur while deleting {{$node.BaseNodeName}}: %+v",objToUpdate.GetName())
					return nil, delErr
				}
				logger.Debugf("{{$node.BaseNodeName}} Deleted: %s",objToUpdate.GetName())
				return nil, err
			}
		} else {
			logger.Debugf("[Update{{$node.BaseNodeName}}ByName] Patch {{$node.BaseNodeName}} Success :%s",objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("{{$node.CrdName}}"); ok {
				logger.Debugf("[Update{{$node.BaseNodeName}}ByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	logger.Debugf("[Update{{$node.BaseNodeName}}ByName] Executed Successfully %s",objToUpdate.GetName())
	return &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
	client: group.client,
		{{$node.BaseNodeName}}: result,
	}, nil
}

// List{{$node.GroupResourceNameTitle}} returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *{{$node.GroupTypeName}}) List{{$node.GroupResourceNameTitle}}(ctx context.Context,
	opts metav1.ListOptions) (result []*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, err error) {
	key := "{{$node.CrdName}}"
	if s,ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, len(items))
		for k, v := range items {
			item, _ := v.(*{{$node.GroupBaseImport}})
			result[k] = &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
				client: group.client,
				{{$node.BaseNodeName}}: item,
			}
		}
	} else {
		list, err := group.client.baseClient.{{$node.GroupTypeName}}().
		{{$node.GroupResourceNameTitle}}().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
				client: group.client,
				{{$node.BaseNodeName}}: &item,
			}
		}
	}
	return
}

type {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} struct {
	client *Clientset
	*{{$node.GroupBaseImport}}
}

// Delete removes obj and all it's children from the database.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Delete(ctx context.Context) error {
	err := obj.client.{{$node.SimpleGroupTypeName}}().Delete{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.{{$node.BaseNodeName}} = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Update(ctx context.Context) error {
	result, err := obj.client.{{$node.SimpleGroupTypeName}}().Update{{$node.BaseNodeName}}ByName(ctx, obj.{{$node.BaseNodeName}})
	if err != nil {
		return err
	}
	obj.{{$node.BaseNodeName}} = result.{{$node.BaseNodeName}}
	return nil
}

{{if .HasStatus}}
// Set{{.StatusName}} sets user defined status
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Set{{.StatusName}}(ctx context.Context, status *{{$node.BaseImportName}}.{{$node.StatusType}}) error {
	logger.Debugf("[{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} Set{{.StatusName}}] Set status for object with name %s", obj.GetName())
	result, err := obj.client.{{$node.SimpleGroupTypeName}}().Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName(ctx, obj.{{$node.BaseNodeName}}, status)
	if err != nil {
		logger.Errorf("[{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} Set{{.StatusName}}] Set status for object with name %s failed with error %v", obj.GetName(), err)
		return err
	}
	obj.{{$node.BaseNodeName}} = result.{{$node.BaseNodeName}}
	return nil
}

// Get{{$node.StatusName}} to get user defined status
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Get{{$node.StatusName}}(ctx context.Context) (*{{$node.BaseImportName}}.{{$node.StatusType}}, error) {
	getObj, err := obj.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.{{$node.StatusName}}, nil
}

// Clear{{$node.StatusName}} to clear user defined status
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Clear{{$node.StatusName}}(ctx context.Context) error {
	logger.Debugf("[{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} Clear{{$node.StatusName}}] Set status for object with name %s", obj.GetName())
	result, err := obj.client.{{$node.SimpleGroupTypeName}}().Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName(ctx, obj.{{$node.BaseNodeName}}, &{{$node.BaseImportName}}.{{$node.StatusType}}{})
	if err != nil {
		logger.Errorf("[{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} Clear{{$node.StatusName}}] Clear status for object with name %s failed with error %v", obj.GetName(), err)
		return err
	}
	obj.{{$node.BaseNodeName}} = result.{{$node.BaseNodeName}}
	return nil
}
{{ end }}

{{ if .Parent.HasParent }}
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) GetParent(ctx context.Context) (result *{{$node.Parent.SimpleGroupTypeName}}{{$node.Parent.BaseNodeName}}, err error) {
	hashedName := helper.GetHashedName("{{$node.Parent.CrdName}}", obj.Labels, obj.Labels["{{$node.Parent.CrdName}}"])
	logger.Debugf("[GetParent] Get parent of {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} name %s [labels %#v] of parent type {{$node.Parent.CrdName}} and name %s", obj.Name, obj.Labels, hashedName)
	return obj.client.{{$node.Parent.SimpleGroupTypeName}}().Get{{$node.Parent.BaseNodeName}}ByName(ctx, hashedName)
}
{{ end }}

{{ if not .Parent.HasParent }}
{{ if $node.IsSingleton}}
// Get{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates the hashed name based on parents and
// returns given object
func (c *Clientset) Get{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context) (result *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", nil, helper.DefaultKey)
	return c.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, hashedName)
}

func (c *Clientset) {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}() *{{$node.GroupResourceType}}Chainer {
	parentLabels := make(map[string]string)
	parentLabels["{{$node.CrdName}}"] = helper.DefaultKey
	return &{{$node.GroupResourceType}}Chainer{
		client:       c,
		name:  helper.DefaultKey,
		parentLabels: parentLabels,
	}
}
// Add{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates hashed name of the object based on
// parents names and creates it. objToCreate.Name is changed to the hashed name. Original name (helper.DefaultKey) is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) Add{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context,
		objToCreate *{{$node.GroupBaseImport}}) (result *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DefaultKey)
	}
	if objToCreate.GetName() != helper.DefaultKey {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.{{$node.SimpleGroupTypeName}}().Create{{$node.BaseNodeName}}ByName(ctx, objToCreate)
}

// Delete{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates hashedName of object based on
// parents and deletes given object
func (c *Clientset) Delete{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", nil, helper.DefaultKey)
	return c.{{$node.SimpleGroupTypeName}}().Delete{{$node.BaseNodeName}}ByName(ctx, hashedName)
}
{{ else }}
// Get{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates the hashed name based on parents and displayName and
// returns given object
func (c *Clientset) Get{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context, displayName string) (result *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", nil, displayName)
	return c.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, hashedName)
}

func (c *Clientset) {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(displayName string) *{{$node.GroupResourceType}}Chainer {
	parentLabels := make(map[string]string)
	parentLabels["{{$node.CrdName}}"] = displayName
	return &{{$node.GroupResourceType}}Chainer{
		client:       c,
		name:  displayName,
		parentLabels: parentLabels,
	}
}
// Add{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates hashed name of the object based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) Add{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context,
		objToCreate *{{$node.GroupBaseImport}}) (result *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.{{$node.SimpleGroupTypeName}}().Create{{$node.BaseNodeName}}ByName(ctx, objToCreate)
}

// Delete{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} calculates hashedName of object based on displayName and
// parents and deletes given object
func (c *Clientset) Delete{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}(ctx context.Context, displayName string) (err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", nil, displayName)
	return c.{{$node.SimpleGroupTypeName}}().Delete{{$node.BaseNodeName}}ByName(ctx, hashedName)
}
{{ end }}
{{ end }}

{{ range $key, $link := .Children }}
{{ if $link.IsNamed }}

type {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{{$link.FieldName}} struct {
       client *Clientset
       {{$link.FieldName}} []{{$node.BaseImportName}}.Child
}

func (n *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{{$link.FieldName}}) Next(ctx context.Context) (*{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, error) {
       for index, child := range n.{{$link.FieldName}} {
               logger.Debugf("[{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{{$link.FieldName}} Next] Get next {{$link.FieldName}} with name %s", child.Name)
               obj, err := n.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, child.Name)
               if err == nil {
                       if index == len(n.{{$link.FieldName}})-1 {
                               n.{{$link.FieldName}} = nil
                       } else {
                               n.{{$link.FieldName}} = n.{{$link.FieldName}}[index+1:]
                       }
                       return obj, nil
               } else if errors.IsNotFound(err) {
                       continue
               } else {
                       return nil, err
               }
       }
       return nil, nil
}

// GetAll{{$link.FieldName}}Iter returns an iterator for all children of given type
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) GetAll{{$link.FieldName}}Iter(ctx context.Context) (
               result {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{{$link.FieldName}}) {
    result.client = obj.client
	for _, v := range GetChildren("{{$node.CrdName}}", obj.Name, "{{$link.CrdName}}") {
		result.{{$link.FieldName}} = append(result.{{$link.FieldName}}, {{$node.BaseImportName}}.Child{
			Group: "{{$link.Group}}",
			Kind: "{{$link.Kind}}",
			Name: v,
		})
	}
    return
}

// GetAll{{$link.FieldName}} returns all children of a given type
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) GetAll{{$link.FieldName}}(ctx context.Context) (
		result []*{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	for _, v := range GetChildren("{{$node.CrdName}}", obj.Name, "{{$link.CrdName}}") {
		logger.Debugf("[{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} GetAll{{$link.FieldName}}] Get next {{$link.FieldName}} with name %s", v)
		l, err := obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// Get{{$link.FieldName}} returns child which has given displayName
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Get{{$link.FieldName}}(ctx context.Context,
		displayName string) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["{{$node.CrdName}}"] = obj.DisplayName()
	childHashName := helper.GetHashedName("{{$link.CrdName}}", parentLabels, displayName)
	logger.Debugf("[Get{{$link.FieldName}}] in {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}} with name %s, displayName %s, parentLabels %#v", childHashName, displayName, parentLabels)
	if IsChildExists("{{$node.CrdName}}", obj.Name, "{{$link.CrdName}}", childHashName) == false {
		logger.Debugf("[Get{{$link.FieldName}}] ChildNotFound {{$link.FieldName}} with name %s, displayName %s ", childHashName, displayName)
		return nil, NewChildNotFound(obj.DisplayName(), "{{$node.SimpleGroupTypeName}}.{{$node.BaseNodeName}}", "{{$link.FieldName}}", displayName)
	}

	logger.Debugf("[Get{{$link.FieldName}}] invoke Get{{$link.BaseNodeName}}ByName name %s, displayName %s", childHashName, displayName)
	result, err = obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, childHashName)
	return
}

{{ else }}
// Get{{$link.FieldName}} returns child of given type
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Get{{$link.FieldName}}(ctx context.Context) (
		result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	children := GetChildren("{{$node.CrdName}}", obj.Name, "{{$link.CrdName}}")
	if len(children) == 0 {
			return nil, NewChildNotFound(obj.DisplayName(), "{{$node.SimpleGroupTypeName}}.{{$node.BaseNodeName}}", "{{$link.FieldName}}")
	}
	return obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, children[0])
}
{{ end }}

// Add{{$link.FieldName}} calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Add{{$link.FieldName}}(ctx context.Context,
	objToCreate *{{$link.GroupBaseImport}}) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	logger.Debugf("[Add{{$link.FieldName}}] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["{{$node.CrdName}}"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["{{$node.CrdName}}"] = obj.DisplayName()
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" { {{ if $link.IsSingleton}}
	if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DefaultKey)
		}
		if objToCreate.GetName() != helper.DefaultKey {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}{{ end }}
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.{{$link.SimpleGroupTypeName}}().Create{{$link.BaseNodeName}}ByName(ctx, objToCreate)
	logger.Debugf("[Add{{$link.FieldName}}] {{$link.BaseNodeName}} created successfully: %s", objToCreate.GetName())
	updatedObj, getErr :=  obj.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if getErr == nil {
		obj.{{$node.BaseNodeName}} = updatedObj.{{$node.BaseNodeName}}
	}
	logger.Debugf("[Add{{$link.FieldName}}] Executed Successfully: %s", objToCreate.GetName())
	return
}

// Delete{{$link.FieldName}} calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
{{ if $link.IsNamed }}
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Delete{{$link.FieldName}}(ctx context.Context, displayName string) (err error) {
	logger.Debugf("[ Delete{{$link.FieldName}}] Received for {{$link.BaseNodeName}} object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["{{$node.CrdName}}"] = obj.DisplayName()
	childHashName := helper.GetHashedName("{{$link.CrdName}}", parentLabels, displayName)
	if IsChildExists("{{$node.CrdName}}", obj.Name, "{{$link.CrdName}}", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "{{$node.SimpleGroupTypeName}}.{{$node.BaseNodeName}}", "{{$link.FieldName}}", displayName)
	}

	err = obj.client.{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, childHashName)
	if err != nil {
		return err
	}
	logger.Debugf("[ Delete{{$link.FieldName}}] {{$link.BaseNodeName}} object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if err == nil {
		obj.{{$node.BaseNodeName}} = updatedObj.{{$node.BaseNodeName}}
	}
	return
}
{{ else}}
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Delete{{$link.FieldName}}(ctx context.Context) (err error) {
	children := GetChildren("{{$node.CrdName}}", obj.Name, "{{$link.CrdName}}")
	if len(children) > 1 {
		logger.Panicf("[ Delete{{$link.FieldName}}] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
		{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
	{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, obj.GetName())
	if err == nil {
		obj.{{$node.BaseNodeName}} = updatedObj.{{$node.BaseNodeName}}
	}
	return
}
{{ end }}
{{ end }}

{{ range $key, $link := .Links }}
{{ if $link.IsNamed }}
// GetAll{{$link.FieldName}} returns all links of given type
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) GetAll{{$link.FieldName}}(ctx context.Context) (
		result []*{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	result = make([]*{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, 0, len(obj.Spec.{{$link.FieldName}}Gvk))
	for _, v := range obj.Spec.{{$link.FieldName}}Gvk {
		l, err := obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// Get{{$link.FieldName}} returns link which has given displayName
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Get{{$link.FieldName}}(ctx context.Context,
		displayName string) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	l, ok := obj.Spec.{{$link.FieldName}}Gvk[displayName]
	if !ok {
		return nil, NewLinkNotFound(obj.DisplayName(), "{{$node.SimpleGroupTypeName}}.{{$node.BaseNodeName}}", "{{$link.FieldName}}", displayName)
	}
	result, err = obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, l.Name)
	return
}

{{ else }}
// Get{{$link.FieldName}} returns link of given type
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Get{{$link.FieldName}}(ctx context.Context) (
		result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	if obj.Spec.{{$link.FieldName}}Gvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "{{$node.SimpleGroupTypeName}}.{{$node.BaseNodeName}}", "{{$link.FieldName}}")
	}
	return obj.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, obj.Spec.{{$link.FieldName}}Gvk.Name)
}
{{ end }}
// Link{{$link.FieldName}} links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Link{{$link.FieldName}}(ctx context.Context,
	linkToAdd *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}) (error) {
	{{ if $link.IsNamed }}
	payload := "{\"spec\": {\"{{$link.FieldNameGvk}}\": {\"" + linkToAdd.DisplayName() + "\": {\"name\": \"" + linkToAdd.Name + "\",\"kind\": \"{{$link.Kind}}\", \"group\": \"{{$link.Group}}\"}}}}"
	result, err := obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Patch(ctx, obj.Name, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
	if err != nil {
		return err
	}
	{{ else }}
	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/{{$link.FieldNameGvk}}",
		Value: {{$node.BaseImportName}}.Child{
		Group: "{{$link.Group}}",
		Kind:  "{{$link.Kind}}",
		Name:  linkToAdd.Name,
	},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	{{ end }}
	obj.{{$node.BaseNodeName}} = result
	return nil
}

// Unlink{{$link.FieldName}} unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) Unlink{{$link.FieldName}}(ctx context.Context{{if $link.IsNamed}},
	linkToRemove *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}{{end}}) (err error) {
	var patch Patch
	{{if $link.IsNamed}}
	patchOp := PatchOp{
		Op:    "remove",
		Path:  "/spec/{{$link.FieldNameGvk}}/" + linkToRemove.DisplayName(),
	}
	{{ else }}
	patchOp := PatchOp{
		Op:    "remove",
		Path:  "/spec/{{$link.FieldNameGvk}}",
	}
	{{ end }}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.{{$node.GroupTypeName}}().{{$node.GroupResourceNameTitle}}().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.{{$node.BaseNodeName}} = result
	return nil

}
{{ end }}

type {{$node.GroupResourceType}}Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *{{$node.GroupResourceType}}Chainer) Subscribe(){
    key := "{{$node.CrdName}}"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := {{$node.GroupInformerImport}}.New{{$node.BaseNodeName}}Informer(c.client.baseClient, informerResyncPeriod * time.Second, cache.Indexers{})
		subscribe(key, informer)
		{{if .Parent.HasParent}}
		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)
		{{end}}
	}
}

func (c *{{$node.GroupResourceType}}Chainer) Unsubscribe(){
	key := "{{$node.CrdName}}"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *{{$node.GroupResourceType}}Chainer) IsSubscribed() bool {
	key := "{{$node.CrdName}}"
	 _, ok := subscriptionMap.Load(key)
	 return ok
}

{{if .Parent.HasParent}}
func (c *{{$node.GroupResourceType}}Chainer) addCallback(obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["{{.Parent.CrdName}}"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("{{.Parent.CrdName}}", obj.Labels, parentDisplayName)
	logger.Debugf("[addCallback] received for {{$node.CrdName}} name %s displayName %s parent {{.Parent.CrdName}} name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	AddChild("{{.Parent.CrdName}}", parentHashName, "{{$node.CrdName}}", obj.Name)
}

func (c *{{$node.GroupResourceType}}Chainer) deleteCallback(obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}) {
	parentDisplayName := helper.DefaultKey
	if value, ok := obj.Labels["{{.Parent.CrdName}}"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("{{.Parent.CrdName}}", obj.Labels, parentDisplayName)
	logger.Debugf("[deleteCallback] received for {{$node.CrdName}} name %s displayName %s parent {{.Parent.CrdName}} name %s parentDisplayName %s", obj.Name, obj.DisplayName(), parentHashName, parentDisplayName)

	RemoveChild("{{.Parent.CrdName}}", parentHashName, "{{$node.CrdName}}", obj.Name)
}
{{end}}

func (c *{{$node.GroupResourceType}}Chainer) RegisterEventHandler(addCB func(obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}), updateCB func(oldObj, newObj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}), deleteCB func(obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}})) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	    informer cache.SharedIndexInformer
	)
	key := "{{$node.CrdName}}"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, so creating a new one")
		informer = {{$node.GroupInformerImport}}.New{{$node.BaseNodeName}}Informer(c.client.baseClient, informerResyncPeriod * time.Second, cache.Indexers{})
		subscribe(key, informer)

		{{if .Parent.HasParent}}
		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)
		{{end}}
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}){
			nc := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
			client: c.client,
				{{$node.BaseNodeName}}: obj.(*{{$node.GroupBaseImport}}),
			}
			logger.Debugf("[RegisterEventHandler AddFunc] Got Add event for {{$node.CrdName}} name %s", nc.{{$node.BaseNodeName}}.Name)

			{{if .Parent.HasParent}}
			var parent *{{.Parent.SimpleGroupTypeName}}{{.Parent.BaseNodeName}}
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("{{.Parent.CrdName}}", nc.Labels, nc.Labels["{{.Parent.CrdName}}"])
				parent, err = c.client.{{.Parent.SimpleGroupTypeName}}().ForceRead{{.Parent.BaseNodeName}}ByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if ! IsChildExists("{{.Parent.CrdName}}", parent.Name, "{{$node.CrdName}}", nc.Name) {
				AddChild("{{.Parent.CrdName}}", parent.Name, "{{$node.CrdName}}", nc.Name)
			}
			{{end}}
			addCB(nc)
		},

		UpdateFunc: func(oldObj,newObj interface{}){
			oldData := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
				client: c.client,
				{{$node.BaseNodeName}}: oldObj.(*{{$node.GroupBaseImport}}),
			}
			newData := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
				client: c.client,
				{{$node.BaseNodeName}}: newObj.(*{{$node.GroupBaseImport}}),
			}
			logger.Debugf("[RegisterEventHandler UpdateFunc] Got Update event for {{$node.CrdName}} name %s old version %s new version %s", oldData.{{$node.BaseNodeName}}.Name, oldData.ResourceVersion, newData.ResourceVersion)
			updateCB(oldData,newData)
        },

		DeleteFunc: func(obj interface{}){
			nc := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
			client: c.client,
				{{$node.BaseNodeName}}: obj.(*{{$node.GroupBaseImport}}),
			}
			logger.Debugf("[RegisterEventHandler DeleteFunc] Got Delete event for {{$node.CrdName}} name %s", nc.{{$node.BaseNodeName}}.Name)

			{{if .Parent.HasParent}}
			var parent *{{.Parent.SimpleGroupTypeName}}{{.Parent.BaseNodeName}}
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if errors.IsNotFound(err) {
					break
				} else if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("{{.Parent.CrdName}}", nc.Labels, nc.Labels["{{.Parent.CrdName}}"])
				parent, err = c.client.{{.Parent.SimpleGroupTypeName}}().ForceRead{{.Parent.BaseNodeName}}ByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("{{.Parent.CrdName}}", parent.Name, "{{$node.CrdName}}", nc.Name) {
				RemoveChild("{{.Parent.CrdName}}", parent.Name, "{{$node.CrdName}}", nc.Name)
			}
			{{end}}
			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *{{$node.GroupResourceType}}Chainer) RegisterAddCallback(cbfn func(obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}})) (cache.ResourceEventHandlerRegistration, error){
	logger.Debugf("[RegisterAddCallback] Received for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err error
		informer       cache.SharedIndexInformer
	)

	key := "{{$node.CrdName}}"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, so creating a new one")
		informer = {{$node.GroupInformerImport}}.New{{$node.BaseNodeName}}Informer(c.client.baseClient, informerResyncPeriod * time.Second, cache.Indexers{})
		subscribe(key, informer)

		{{if .Parent.HasParent}}
		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)
		{{end}}
	}

    registrationId,err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
            AddFunc: func(obj interface{}){
				nc := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
					client: c.client,
					{{$node.BaseNodeName}}: obj.(*{{$node.GroupBaseImport}}),
				}
				logger.Debugf("[RegisterAddCallback] Got Add event for {{$node.CrdName}} name %s", nc.{{$node.BaseNodeName}}.Name)

				{{if .Parent.HasParent}}
				var parent *{{.Parent.SimpleGroupTypeName}}{{.Parent.BaseNodeName}}
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}
				if parent == nil {
					hashedName := helper.GetHashedName("{{.Parent.CrdName}}", nc.Labels, nc.Labels["{{.Parent.CrdName}}"])
					parent, err = c.client.{{.Parent.SimpleGroupTypeName}}().ForceRead{{.Parent.BaseNodeName}}ByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if ! IsChildExists("{{.Parent.CrdName}}", parent.Name, "{{$node.CrdName}}", nc.Name) {
					AddChild("{{.Parent.CrdName}}", parent.Name, "{{$node.CrdName}}", nc.Name)
				}
				{{end}}

				cbfn(nc)
            },
        })

	return registrationId,err
}

func (c *{{$node.GroupResourceType}}Chainer) RegisterUpdateCallback(cbfn func(oldObj,newObj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}})) (cache.ResourceEventHandlerRegistration, error){
	logger.Debugf("[RegisterUpdateCallback] Received for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err error
		informer       cache.SharedIndexInformer
	)

	key := "{{$node.CrdName}}"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, so creating a new one")
		informer = {{$node.GroupInformerImport}}.New{{$node.BaseNodeName}}Informer(c.client.baseClient, informerResyncPeriod * time.Second, cache.Indexers{})
		subscribe(key, informer)

		{{if .Parent.HasParent}}
		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)
		{{end}}
	}

	registrationId,err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
            UpdateFunc: func(oldObj,newObj interface{}){
				oldData := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
					client: c.client,
					{{$node.BaseNodeName}}: oldObj.(*{{$node.GroupBaseImport}}),
				}
				newData := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
					client: c.client,
					{{$node.BaseNodeName}}: newObj.(*{{$node.GroupBaseImport}}),
				}
				logger.Debugf("[RegisterUpdateCallback] Got Update event for {{$node.CrdName}} name %s old version %s new version %s", oldData.{{$node.BaseNodeName}}.Name, oldData.ResourceVersion, newData.ResourceVersion)
				cbfn(oldData,newData)
            },
        })

	return registrationId,err
}

func (c *{{$node.GroupResourceType}}Chainer) RegisterDeleteCallback(cbfn func(obj *{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}})) (cache.ResourceEventHandlerRegistration, error){
	logger.Debugf("[RegisterDeleteCallback] Received for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err error
		informer       cache.SharedIndexInformer
	)

	key := "{{$node.CrdName}}"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for {{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}, so creating a new one")
		informer = {{$node.GroupInformerImport}}.New{{$node.BaseNodeName}}Informer(c.client.baseClient, informerResyncPeriod * time.Second, cache.Indexers{})
		subscribe(key, informer)

		{{if .Parent.HasParent}}
		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)
		{{end}}
	}

    registrationId,err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
            DeleteFunc: func(obj interface{}){
				nc := &{{$node.SimpleGroupTypeName}}{{$node.BaseNodeName}}{
				client: c.client,
					{{$node.BaseNodeName}}: obj.(*{{$node.GroupBaseImport}}),
				}
				logger.Debugf("[RegisterDeleteCallback] Got Delete event for {{$node.CrdName}} name %s", nc.{{$node.BaseNodeName}}.Name)

				{{if .Parent.HasParent}}
				var parent *{{.Parent.SimpleGroupTypeName}}{{.Parent.BaseNodeName}}
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if errors.IsNotFound(err) {
						break
					} else if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("{{.Parent.CrdName}}", nc.Labels, nc.Labels["{{.Parent.CrdName}}"])
					parent, err = c.client.{{.Parent.SimpleGroupTypeName}}().ForceRead{{.Parent.BaseNodeName}}ByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}
				if IsChildExists("{{.Parent.CrdName}}", parent.Name, "{{$node.CrdName}}", nc.Name) {
					RemoveChild("{{.Parent.CrdName}}", parent.Name, "{{$node.CrdName}}", nc.Name)
				}
				{{end}}

				cbfn(nc)
			},
        })

	return registrationId,err
}

{{if .HasStatus}}
// Clear{{$node.StatusName}} to clear user defined status
func (c *{{$node.GroupResourceType}}Chainer) Clear{{$node.StatusName}}(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", c.parentLabels, c.name)
	logger.Debugf("[{{$node.GroupResourceType}}Chainer Clear{{$node.StatusName}}] Clear status for object with name %s", hashedName)
	obj, err := c.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, hashedName)
	if err != nil {
		logger.Errorf("[{{$node.GroupResourceType}}Chainer Clear{{$node.StatusName}}] Clear status for object with name %s failed with error %v", hashedName, err)
		return err
	}
	_, err = c.client.{{$node.SimpleGroupTypeName}}().Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName(ctx, obj.{{$node.BaseNodeName}}, nil)
	return err
}

// Get{{$node.StatusName}} to get user defined status
func (c *{{$node.GroupResourceType}}Chainer) Get{{$node.StatusName}}(ctx context.Context) (result *{{$node.BaseImportName}}.{{$node.StatusType}}, err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", c.parentLabels, c.name)
	obj, err := c.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.{{$node.StatusName}}, nil
}

// Set{{$node.StatusName}} sets user defined status
func (c *{{$node.GroupResourceType}}Chainer) Set{{$node.StatusName}}(ctx context.Context, status *{{$node.BaseImportName}}.{{$node.StatusType}}) (err error) {
	hashedName := helper.GetHashedName("{{$node.CrdName}}", c.parentLabels, c.name)
	logger.Debugf("[{{$node.GroupResourceType}}Chainer Set{{$node.StatusName}}] Set status for object with name %s", hashedName)
	obj, err := c.client.{{$node.SimpleGroupTypeName}}().Get{{$node.BaseNodeName}}ByName(ctx, hashedName)
	if err != nil {
		logger.Errorf("[{{$node.GroupResourceType}}Chainer Set{{$node.StatusName}}] Set status for object with name %s failed with error %v", hashedName, err)
		return err
	}
	_, err = c.client.{{$node.SimpleGroupTypeName}}().Set{{$node.BaseNodeName}}{{$node.StatusName}}ByName(ctx, obj.{{$node.BaseNodeName}}, status)
	return err
}
{{ end }}

{{ range $key, $link := .Children }}
{{ if $link.IsSingleton }}
func (c *{{$node.GroupResourceType}}Chainer) {{$link.FieldName}}() *{{$link.GroupResourceType}}Chainer {
	parentLabels := c.parentLabels
	parentLabels["{{$link.CrdName}}"] = helper.DefaultKey
	return &{{$link.GroupResourceType}}Chainer{
		client: c.client,
		name: helper.DefaultKey,
		parentLabels: parentLabels,
	}
}

// Get{{$link.FieldName}} calculates hashed name of the object based on it's parents and returns the object
func (c *{{$node.GroupResourceType}}Chainer) Get{{$link.FieldName}}(ctx context.Context) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, helper.DefaultKey)
	return c.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, hashedName)
}

// Add{{$link.FieldName}} calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *{{$node.GroupResourceType}}Chainer) Add{{$link.FieldName}}(ctx context.Context,
		objToCreate *{{$link.GroupBaseImport}}) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DefaultKey)
	}
	if objToCreate.GetName() != helper.DefaultKey {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.{{$link.SimpleGroupTypeName}}().Create{{$link.BaseNodeName}}ByName(ctx, objToCreate)
}

// Delete{{$link.FieldName}} calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *{{$node.GroupResourceType}}Chainer) Delete{{$link.FieldName}}(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, name)
	return c.client.{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, hashedName)
}
{{ else }}
func (c *{{$node.GroupResourceType}}Chainer) {{$link.FieldName}}(name string) *{{$link.GroupResourceType}}Chainer {
	parentLabels := c.parentLabels
	parentLabels["{{$link.CrdName}}"] = name
	return &{{$link.GroupResourceType}}Chainer{
		client: c.client,
		name: name,
		parentLabels: parentLabels,
	}
}

// Get{{$link.FieldName}} calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *{{$node.GroupResourceType}}Chainer) Get{{$link.FieldName}}(ctx context.Context, displayName string) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, displayName)
	logger.Debugf("[Get{{$link.FieldName}}] using chainer for name %s, displayName %s, labels %#v", hashedName, displayName, c.parentLabels)
	return c.client.{{$link.SimpleGroupTypeName}}().Get{{$link.BaseNodeName}}ByName(ctx, hashedName)
}

// Add{{$link.FieldName}} calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *{{$node.GroupResourceType}}Chainer) Add{{$link.FieldName}}(ctx context.Context,
	objToCreate *{{$link.GroupBaseImport}}) (result *{{$link.SimpleGroupTypeName}}{{$link.BaseNodeName}}, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IsNameHashedLabel] != "true" {
		objToCreate.Labels[common.DisplayNameLabel] = objToCreate.GetName()
		objToCreate.Labels[common.IsNameHashedLabel] = "true"
		hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.{{$link.SimpleGroupTypeName}}().Create{{$link.BaseNodeName}}ByName(ctx, objToCreate)
}

// Delete{{$link.FieldName}} calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *{{$node.GroupResourceType}}Chainer) Delete{{$link.FieldName}}(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IsNameHashedLabel] = "true"
	hashedName := helper.GetHashedName("{{$link.CrdName}}", c.parentLabels, name)
	return c.client.{{$link.SimpleGroupTypeName}}().Delete{{$link.BaseNodeName}}ByName(ctx, hashedName)
}

{{ end }}
{{ end }}
{{ end }}
